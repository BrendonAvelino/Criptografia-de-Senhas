<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Criptografar / Descriptografar (Web Crypto API)</title>
<style>
  :root{--bg:#f5f7fb;--card:#fff;--accent:#1465b3;--muted:#6b7280}
  *{box-sizing:border-box;font-family:Inter,system-ui,Arial,sans-serif}
  body{margin:0;min-height:100vh;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,var(--bg),#eef2f7);padding:24px;color:#0f1724}
  .container{width:100%;max-width:820px;background:var(--card);border-radius:12px;box-shadow:0 10px 30px rgba(2,6,23,0.08);padding:18px}
  h1{margin:0 0 8px;font-size:20px}
  p{margin:0 0 14px;color:var(--muted)}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px}
  input, textarea, select{width:100%;padding:10px 12px;border-radius:8px;border:1px solid #e6e9ee;font-size:14px;background:#fbfdff}
  textarea{min-height:90px;resize:vertical}
  .controls{display:flex;gap:8px;margin-top:12px;flex-wrap:wrap}
  button{background:var(--accent);color:#fff;border:none;padding:10px 12px;border-radius:8px;cursor:pointer;font-weight:600}
  button.ghost{background:transparent;color:var(--accent);border:1px solid #dbeafe}
  .result{margin-top:14px;padding:12px;background:#f8fafc;border-radius:8px;border:1px dashed #e6eefc;word-break:break-all}
  .note{font-size:13px;color:#475569;margin-top:10px}
  @media(max-width:700px){.grid{grid-template-columns:1fr}}
</style>
</head>
<body>
  <div class="container">
    <h1>Criptografia reversÃ­vel (AES-GCM) â€” Web Crypto API</h1>
    <p>Insira uma senha (ou qualquer texto) e uma passphrase. Para descriptografar use a mesma passphrase.</p>

    <div class="grid">
      <div>
        <label for="plain">Texto a criptografar</label>
        <input id="plain" type="text" placeholder="ex: minhaSenhaSecreta">
      </div>

      <div>
        <label for="pass">Passphrase (chave secreta)</label>
        <input id="pass" type="password" placeholder="sua-passphrase-secreta">
      </div>

      <div>
        <label for="iterations">PBKDF2 iteraÃ§Ãµes</label>
        <select id="iterations">
          <option value="60000">60.000</option>
          <option value="100000" selected>100.000 (recomendado)</option>
          <option value="200000">200.000 (mais lento)</option>
        </select>
      </div>

      <div>
        <label for="cipher">Texto criptografado (Base64)</label>
        <textarea id="cipher" placeholder="Aqui aparecerÃ¡ o texto criptografado"></textarea>
      </div>

      <div style="grid-column:1/-1">
        <div class="controls">
          <button id="encBtn">ðŸ”’ Criptografar</button>
          <button id="decBtn" class="ghost">ðŸ”“ Descriptografar</button>
          <button id="copyBtn" class="ghost">ðŸ“‹ Copiar resultado</button>
          <button id="clearBtn" class="ghost">ðŸ§¹ Limpar</button>
        </div>
      </div>

      <div>
        <label for="out">Resultado (texto descriptografado)</label>
        <input id="out" type="text" readonly placeholder="Texto decodificado aparecerÃ¡ aqui">
      </div>

      <div>
        <label>&nbsp;</label>
        <div style="font-size:13px;color:var(--muted)">Formato do resultado: Base64 contendo <strong>salt(16 bytes)||iv(12 bytes)||ciphertext</strong>. Guarde o Base64 e a passphrase.</div>
      </div>
    </div>

    <div class="result" id="log">Pronto â€” insira valores e clique em Criptografar.</div>
    <div class="note">
      Nota: este exemplo Ã© para uso pessoal/educacional. Para aplicaÃ§Ãµes reais, gerencie chaves com seguranÃ§a e prefira operaÃ§Ãµes no servidor.
    </div>
  </div>

<script>
/* ---------- Helpers (ArrayBuffer <-> Base64 / utils) ---------- */
const enc = new TextEncoder();
const dec = new TextDecoder();

function bufToBase64(buf){
  // buf: ArrayBuffer
  const bytes = new Uint8Array(buf);
  let binary = '';
  const chunk = 0x8000;
  for (let i = 0; i < bytes.length; i += chunk) {
    binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunk));
  }
  return btoa(binary);
}

function base64ToBuf(b64){
  const binary = atob(b64);
  const len = binary.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
  return bytes.buffer;
}

function concatArrayBuffers(...buffers){
  const totalLength = buffers.reduce((s,b)=>s + b.byteLength, 0);
  const tmp = new Uint8Array(totalLength);
  let offset = 0;
  for (const b of buffers){
    tmp.set(new Uint8Array(b), offset);
    offset += b.byteLength;
  }
  return tmp.buffer;
}

/* ---------- Crypto primitives ---------- */

// Gera chave derivada via PBKDF2 usando passphrase + salt
async function deriveKey(passphrase, salt, iterations=100000, hash='SHA-256', keyLength=256){
  const passKey = await crypto.subtle.importKey(
    'raw',
    enc.encode(passphrase),
    {name: 'PBKDF2'},
    false,
    ['deriveKey']
  );

  const derivedKey = await crypto.subtle.deriveKey(
    {
      name: 'PBKDF2',
      salt: salt,
      iterations: iterations,
      hash: hash
    },
    passKey,
    { name: 'AES-GCM', length: keyLength },
    false,
    ['encrypt','decrypt']
  );

  return derivedKey;
}

// Criptografa texto (UTF-8) retornando Base64 contendo salt||iv||ciphertext
async function encryptText(plainText, passphrase, iterations=100000){
  if(!plainText) throw new Error('Texto vazio.');
  if(!passphrase) throw new Error('Passphrase vazia.');

  // salt 16 bytes, iv 12 bytes (recomendado para GCM)
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const iv = crypto.getRandomValues(new Uint8Array(12));

  const key = await deriveKey(passphrase, salt.buffer, iterations);

  const cipherBuffer = await crypto.subtle.encrypt(
    { name: 'AES-GCM', iv: iv },
    key,
    enc.encode(plainText)
  );

  // Combine salt + iv + ciphertext
  const combined = concatArrayBuffers(salt.buffer, iv.buffer, cipherBuffer);
  return bufToBase64(combined);
}

// Descriptografa Base64 (salt||iv||cipher) usando passphrase
async function decryptText(b64combined, passphrase, iterations=100000){
  if(!b64combined) throw new Error('Texto criptografado vazio.');
  if(!passphrase) throw new Error('Passphrase vazia.');

  const combinedBuf = base64ToBuf(b64combined);
  const combined = new Uint8Array(combinedBuf);

  if (combined.length < 16 + 12 + 1) throw new Error('Formato invÃ¡lido (tamanho muito pequeno).');

  const salt = combined.slice(0,16).buffer;
  const iv = combined.slice(16,28).buffer;
  const cipher = combined.slice(28).buffer;

  const key = await deriveKey(passphrase, salt, iterations);

  let plainBuffer;
  try{
    plainBuffer = await crypto.subtle.decrypt(
      { name: 'AES-GCM', iv: new Uint8Array(iv) },
      key,
      cipher
    );
  }catch(e){
    throw new Error('Falha na descriptografia. PossÃ­vel passphrase errada ou dado corrompido.');
  }

  return dec.decode(plainBuffer);
}

/* ---------- UI wiring ---------- */
const plainEl = document.getElementById('plain');
const passEl = document.getElementById('pass');
const iterationsEl = document.getElementById('iterations');
const cipherEl = document.getElementById('cipher');
const outEl = document.getElementById('out');
const logEl = document.getElementById('log');
const encBtn = document.getElementById('encBtn');
const decBtn = document.getElementById('decBtn');
const copyBtn = document.getElementById('copyBtn');
const clearBtn = document.getElementById('clearBtn');

function showLog(txt){ logEl.textContent = txt; }

encBtn.addEventListener('click', async ()=>{
  try{
    encBtn.disabled = true;
    const plain = plainEl.value;
    const pass = passEl.value;
    const iters = parseInt(iterationsEl.value, 10);
    showLog('Criptografando â€” isso pode levar um segundo...');
    const result = await encryptText(plain, pass, iters);
    cipherEl.value = result;
    outEl.value = '';
    showLog('Criptografado com sucesso. Copie o Base64 gerado.');
  }catch(e){
    showLog('Erro: ' + e.message);
  }finally{
    encBtn.disabled = false;
  }
});

decBtn.addEventListener('click', async ()=>{
  try{
    decBtn.disabled = true;
    const b64 = cipherEl.value.trim();
    const pass = passEl.value;
    const iters = parseInt(iterationsEl.value, 10);
    showLog('Descriptografando...');
    const original = await decryptText(b64, pass, iters);
    outEl.value = original;
    showLog('Descriptografado com sucesso.');
  }catch(e){
    showLog('Erro: ' + e.message);
  }finally{
    decBtn.disabled = false;
  }
});

copyBtn.addEventListener('click', async ()=>{
  try{
    await navigator.clipboard.writeText(cipherEl.value);
    showLog('Resultado copiado para Ã¡rea de transferÃªncia.');
  }catch(e){
    showLog('Erro ao copiar: ' + (e.message || e));
  }
});

clearBtn.addEventListener('click', ()=>{
  plainEl.value = '';
  passEl.value = '';
  cipherEl.value = '';
  outEl.value = '';
  showLog('Campos limpos.');
});

// Enter em plain = criptografar
plainEl.addEventListener('keydown', (ev)=>{
  if(ev.key === 'Enter' && !ev.shiftKey){ ev.preventDefault(); encBtn.click(); }
});
</script>
</body>
</html>
